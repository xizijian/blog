---
title: 《你不知道的JS》读书笔记（持续更新中）
date: 2022-11-22
description: 
tags:
  - JavaScript
banner: ./potions.jpg
---

## 写在前面
> 偶然听小伙伴提到的一本书，也是各大平台大佬力推的一本书，初读两节，惊为天人，评论区称为神作确实不夸张。
本文持续更新，碎片时间记录一些通过这本书了解到的平时忽略和不清楚的知识点，也鞭策自己坚持下去，查缺补漏，奥利给！

##### 11.22 小记

###### 1.深度解析 **var a = 2**
编译器会进行如下处理:

1. 遇到 var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作
用域的集合中声明一个新的变量，并命名为 a。
2. 接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 a = 2 这个赋值操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作 a 的
变量。如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量。

如果引擎最终找到了 a 变量，就会将 2 赋值给它。否则引擎就会举手示意并抛出一个异常！

**总结：** 变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。

###### 2.LHS/RHS 查询

当变量出现在赋值操作的左侧时进行 **LHS** 查询，出现在右侧时进行 **RHS** 查询。

讲得更准确一点，**RHS** 查询与简单地查找某个变量的值别无二致，而 **LHS** 查询则是试图找到变量的容器本身，从而可以对其赋值。从这个角度说，**RHS** 并不是真正意义上的“赋
值操作的右侧”，更准确地说是“非左侧”。

**LHS** 和 **RHS** 查询都会在当前执行作用域中开始，如果有需要（也就是说它们没有找到所需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域（一层
楼），最后抵达全局作用域（顶层），无论找到或没找到都将停止。


###### 3.ReferenceError、TypeError 异常

为什么区分 **LHS** 和 **RHS** 是一件重要的事情？

因为在变量还没有声明（在任何作用域中都无法找到该变量）的情况下，这两种查询的行为是不一样的。

如下：
```js
function foo(a) {
    console.log( a + b );
    b = a;
}
foo( 2 );
```

第一次对 b 进行 **RHS** 查询时是无法找到该变量的。也就是说，这是一个“未声明”的变量，因为在任何相关的作用域中都无法找到它。

如果 **RHS** 查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出 **ReferenceError** 异常。值得注意的是，**ReferenceError** 是非常重要的异常类型。

相较之下，当引擎执行 **LHS** 查询时，如果在顶层（全局作用域）中也无法找到目标变量，全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎，前提是程序运行在非“严格模式”下。

> “不，这个变量之前并不存在，但是我很热心地帮你创建了一个。”

ES5 中引入了“严格模式”。同正常模式，或者说宽松 / 懒惰模式相比，严格模式在行为上有很多不同。其中一个不同的行为是严格模式禁止自动或隐式地创建全局变量。因此，在
严格模式中 **LHS** 查询失败时，并不会创建并返回一个全局变量，引擎会抛出同 **RHS** 查询失败时类似的 **ReferenceError** 异常。

接下来，如果 **RHS** 查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作，比如试图对一个非函数类型的值进行函数调用，或着引用 null 或 undefined 类型的值中的
属性，那么引擎会抛出另外一种类型的异常，叫作 **TypeError。**

**ReferenceError** 同作用域判别失败相关，而 **TypeError** 则代表作用域判别成功了，但是对结果的操作是非法或不合理的。

###### 作用域小结

作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。如果查找的目的是对变量进行赋值，那么就会使用 **LHS** 查询；如果目的是获取变量的值，就会使用 **RHS** 查询。
赋值操作符会导致 **LHS** 查询。＝操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。